#!/usr/bin/env amm

import $ivy.`co.fs2::fs2-core:0.10.2`
import $ivy.`co.fs2::fs2-io:0.10.2`
import $ivy.`com.lihaoyi::fastparse:1.0.0`

import fs2._
import cats.effect.IO
import cats.implicits._
import ammonite.ops._
import scala.sys.process._

val allRegex = ".*\\.mkv"

@main
def main(crf: Int @doc("The video quality 'constant rate factor'. See http://trac.ffmpeg.org/wiki/Encode/H.264") = 25
  , langs: Seq[String] @doc("Language streams to include") = List("deu,ger,eng")
  , scale: String @doc("Scale the video by WxH") = ""
  , crop: String @doc("Crop the video w:h:x:y") = ""
  , regex: String @doc("Regex to match against complete path") = allRegex
  , overwrite: Boolean @doc("Overwrite existing target files") = false
  , dryRun: Boolean @doc("Only print which files would be transcoded") = false
  , files: Seq[Path] @doc("Files or diretcories with files to convert")
): Unit = {
  implicit val wd = pwd

  val main =
    Stream.emits(files).covary[IO].
      through(listFiles).
      filter(fileMatcher(regex)).
      evalMap(in => {
        val out = makeOutFile(in, crf)
        val check = checkInputFile(in) *> checkOutfile(out, overwrite)
        check.map(_ => (in, out)).attempt
      })

  val task =
    if (dryRun) main.to(printSink)
    else main.to(executeSink(crf, langs, Option(scale).filter(_.nonEmpty), Option(crop).filter(_.nonEmpty)))

  task.compile.drain.unsafeRunSync
}

def printSink: Sink[IO, Either[Throwable, (Path, Path)]] =
  _.map({
    case Right((in, out)) => println(s"Transcode $in to $out")
    case Left(err) => println(s"Error: ${err.getMessage}")
  })

def executeSink(crf: Int
  , langs: Seq[String]
  , scale: Option[String]
  , crop: Option[String])
  (implicit wd: Path): Sink[IO, Either[Throwable, (Path, Path)]] =
  _.evalMap({
    case Left(err) => IO(println(s"Error: ${err.getMessage}"))
    case Right((in, out)) =>
      for {
        _  <- runCommand(in, out, crf, langs, scale, crop)
        _  <- IO(println(s"Transcoded $in to $out"))
      } yield ()
  })


def checkInputFile(in: Path): IO[Unit] = {
  val Outfile = """.*\.transcoded[0-9]+\.mkv""".r
  in.name match {
    case Outfile() => IO.raiseError(new Exception(s"File $in is already transcoded"))
    case _ => IO.pure(())
  }
}

def checkOutfile(out: Path, overwrite: Boolean): IO[Unit] =
  if (exists(out)) {
    if (overwrite) IO(rm.!(out))
    else IO.raiseError(new Exception(s"$out already exists"))
  } else IO.pure(())

def fileMatcher(regex: String): Path => Boolean = {
  val pattern = regex.r
  p => pattern.findFirstMatchIn(p.toString).nonEmpty
}

def listFiles: Pipe[IO, Path, Path] = _.flatMap { p =>
  val info = stat.full(p)
  if (info.isDir) Stream.emits(ls.!(p)).covary[IO].through(listFiles)
  else Stream.emit(p)
}

def makeOutFile(in: Path, crf: Int): Path = {
  val base = in.name.substring(0, in.name.length - in.ext.length - 1)
  val name = s"${base}.transcoded${crf}.mkv"
  in/up/name
}

def runCommand(in: Path
  , out: Path
  , crf: Int
  , langs: Seq[String]
  , scale: Option[String]
  , crop: Option[String])(implicit wd: Path): IO[Unit] = {
  findStreams(in).flatMap { streamdef =>
    val streams = streamdef
      .filter(_.kind == "audio")
      .zipWithIndex
      .filter(t => langs.contains(t._1.lang))
      .groupBy(t => t._1.lang)
      .values.map(_.head)
      .toList //make audio stream order as specified with --langs (doesn't reset default flag)
      .sortWith({ case ((def1, _), (def2, _)) =>
        langs.indexOf(def1.lang) < langs.indexOf(def2.lang)
      })

    val mapOpt = streams.flatMap(t => List("-map", "0:a:" + t._2))
    val audioCodec = Seq("copy")
    // if (streams.forall(t => t._1.details.toLowerCase.contains("stereo") && !t._1.details.toLowerCase.contains("flac"))) Seq("flac")
    // else Seq("copy")

    val cropCfg = crop.map(x => Seq("-vf", "crop=" + x)).getOrElse(Seq())
    val scaleCfg = scale.map(x => Seq("-s", x)).getOrElse(Seq())
    IO {
      println("Running ffmpeg...")
      %("ffmpeg", "-i", in, cropCfg
        , "-map", "0:v:0", scaleCfg
        , "-c:v", "h264"
        , "-crf", crf
        , mapOpt, "-c:a", audioCodec, out)
    }
  }
}

def findStreams(in: Path)(implicit wd: Path): IO[List[StreamDef]] = IO {
  %%("ffprobe", in).err.lines.
    map(StreamDef.Parser.apply).
    collect({case Some(sd) => sd}).
    toList
}

case class StreamDef(
  num: (String, String),
  lang: String,
  kind: String,
  details: String)

object StreamDef {
  // example:
  //  Stream #0:0(eng): Video: h264 (High), yuv420p(tv, bt709), 1920x1080 [SAR 1:1 DAR 16:9], 23.98 fps, 23.98 tbr, 1k tbn, 47.95 tbc
  //  Stream #0:1(eng): Audio: dts (DTS), 48000 Hz, 5.1(side), fltp, 1536 kb/s (default)
  object Parser {
    val White = fastparse.WhitespaceApi.Wrapper {
      import fastparse.all._
      NoTrace(" ".rep)
    }
    import fastparse.noApi._
    import White._

    val num: P[(String, String)] = P("#" ~/ CharIn('0' to '9').rep.! ~ ":" ~ CharIn('0' to '9').rep.!)
    val alpha = P((CharIn('a' to 'z') | CharIn('A' to 'Z')).rep)
    val lang: P[String] = P("(" ~/ alpha.! ~ ")" map { _.toLowerCase.trim })
    val kind: P[String] = P(":" ~/ alpha.! ~ ":" map { _.toLowerCase.trim })
    val rest: P[String] = AnyChar.rep.!
    val streamDef: P[StreamDef] = P(("Stream" ~ num ~ lang ~ kind ~ rest) map {
      case (a, n, l, k, r) => StreamDef((a,n), l, k, r.trim)
    })
    def apply(s: String): Option[StreamDef] = streamDef.parse(s.trim) match {
      case Parsed.Success(d, _) => Some(d)
      case _ => None
    }
  }

}
